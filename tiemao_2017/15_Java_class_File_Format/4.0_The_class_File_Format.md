# Chapter 4. The `class` File Format

# 第4章 class文件格式 - JVM规范文档

This chapter describes the `class` file format of the Java Virtual Machine. Each `class` file contains the definition of a single class or interface. Although a class or interface need not have an external representation literally contained in a file (for instance, because the class is generated by a class loader), we will colloquially refer to any valid representation of a class or interface as being in the `class` file format.

本章主要介绍Java虚拟机 `class` 文件的格式。每个 `class` 文件中包含一个类(class)或接口(interface)的定义. 尽管有些类是通过 class loader 动态生成的, 并不需要有对应的物理文件, 但为了表述方便, 我们将类/接口的有效表示方式称为 `class` 文件格式。


A `class` file consists of a stream of 8-bit bytes. All 16-bit, 32-bit, and 64-bit quantities are constructed by reading in two, four, and eight consecutive 8-bit bytes, respectively. Multibyte data items are always stored in big-endian order, where the high bytes come first. In the Java SE platform, this format is supported by interfaces `java.io.DataInput` and `java.io.DataOutput` and classes such as `java.io.DataInputStream` and `java.io.DataOutputStream`.


`class` 文件由8位(8-bit)的字节流组成(8-bit bytes)。所有的16位、32位和64位数据都由连续的2个,4个,8个字节所组成. 多字节组成的项, 统一存储为大端字节序(big-endian order), 高位字节放在前面。在Java中, 读写这种格式的标准接口是 `java.io.DataInput` 和 `java.io.DataOutput`; 其所有的实现类都支持class文件格式, 比如 `java.io.DataInputStream` 和 `java.io.DataOutputStream` 等。

> **备注**: 大端字节序(big-endian order): 比如数值 `454355811`, 表述为二进制就是 `00011011 00010100 11101011 01100011`; 对应的16进制为 `1B14EB63`, 也可以加上 `0x`的前缀 `0x1B14EB63`;
>
> 从前到后的字节流是: `| 1B | 14 | EB | 63 |`。
>
> 小端字节序, 从前到后的字节流就是: `| 63 | EB | 14 | 1B |`。
>
> 可以看到、小端字节序并不方便人类的直观理解。
>
> ???? 待校对。。。


This chapter defines its own set of data types representing `class` file data: The types `u1`, `u2`, and `u4` represent an unsigned one-, two-, or four-byte quantity, respectively. In the Java SE platform, these types may be read by methods such as `readUnsignedByte`, `readUnsignedShort`, and `readInt` of the interface `java.io.DataInput`.


本章使用的数据类型为: `u1`, `u2`, 和 `u4`, 分别表示无符号(unsigned)的 1字节、2字节和4字节数据. 在Java中, 这些类型可以通过 `java.io.DataInput` 接口的 `readUnsignedByte`, `readUnsignedShort`, and `readInt` 方法来读取。

> "quantity", 本文大部分翻译为 "数据";


This chapter presents the `class` file format using pseudostructures written in a C-like structure notation. To avoid confusion with the fields of classes and class instances, etc., the contents of the structures describing the `class` file format are referred to as *items*. Successive items are stored in the `class` file sequentially, without padding or alignment.


本章使用类C语言方式的伪结构体(pseudo-structures)来表示 `class` 文件格式。为了区别 field(属性域) 和 instance(类实例), `class` 文件对应结构体中的内容称之为 *item(项)*。 各个 item 按顺序保存到 `class` 文件中, 没有补齐(padding)或对齐(alignment)。


*Tables*, consisting of zero or more variable-sized items, are used in several `class` file structures. Although we use C-like array syntax to refer to table items, the fact that tables are streams of varying-sized structures means that it is not possible to translate a table index directly to a byte offset into the table.

*Table(表)*, 由0到多个大小可变的item组成, 在多种结构中都有使用. 虽然我们使用数组的方式来指向 table 中的 item , 但实际上 table 是一串数据流, 由多个不同大小的结构所组成, 也就不能通过下标简单地计算出偏移量。


Where we refer to a data structure as an *array*, it consists of zero or more contiguous fixed-sized items and can be indexed like an array.

而 *array(数组)* 结构, 则包含0到多个, 连续的, 固定尺寸的 item, 可以像数组一样计算出偏移量。


Reference to an ASCII character in this chapter should be interpreted to mean the Unicode code point corresponding to the ASCII character.


本章出现的每个ASCII字符, 都表示对应的Unicode编码。



原文链接: <https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html>



